`
<section>
    <h1>
        Binary Indexed Trees (Fenwick Trees)
    </h1>
<h1>
What are binary indexed trees?
</h1>
<p>
Binary Indexed Trees (BIT), also known as Fenwick Trees, are a data structure that efficiently maintains an array of cumulative sums, allowing for fast updates and queries of prefix sums. They were introduced by Peter Fenwick in 1994. BITs are particularly useful in scenarios where you need to perform frequent updates and queries on cumulative sums, such as finding the sum of elements in a range of an array.
</p>
<p>
The key idea behind a Binary Indexed Tree is to represent the array as a tree structure, where each node stores the cumulative sum of a specific range of elements. The low-order bits of the indices are used to determine the ranges represented by the nodes in the tree. Specifically, the binary representation of the index is used to determine the parent-child relationships in the tree.
</p>
<h1>
Construction
</h1>
<p>
    The construction of a BIT data structure involves 3 essential steps:
</p>
<ul>
<li>
    1. The BIT is usually represented as an array 'BIT[]' that has exactly the same size as the original array.
</li>
<li>
    2. The BIT array is then initialized with zeros.
</li>
<li>
    3. The BIT array is then updated to store cumulative sums based on the input array.
</li>
</ul>
<p>
    Note: The update operation mentioned at step 3 is further explained below.
</p>
<h1>
Update Operation
</h1>
<p>
    To update an element at index 'i' in the original array, traverse the BIT tree and update all nodes that cover the range of the element.
</p>
<p>
    The update is done by adding the change in value to each affected node.
</p>
<h1>
Query Operation
</h1>
<p>
To calculate the prefix sum up to index i in the original array, traverse the BIT tree and accumulate the values of nodes covering the range of the prefix sum.
</p>
<h1>
Implementation
</h1>
<pre>
<code>
#include <iostream>
#include <vector>
using namespace std;

void update(vector<int>& BIT, int i, int delta)
{
    while(i < BIT.size())
    {
        BIT[i] += delta;
        i += i & -i;
    }
}

int query(const vector<int>& BIT, int i) {
    int result = 0;
    while (i > 0) {
        result += BIT[i];
        i -= i & -i;
    }
    return result;
}

vector<int> construct_BIT(const vector<int>& array) {
    int n = array.size();
    vector<int> BIT(n + 1, 0);

    for (int i = 1; i <= n; ++i) {
        update(BIT, i, array[i - 1]);
    }

    return BIT;
}

int main() {
    vector<int> arr = {1, 2, 3, 4, 5, 6, 7, 8, 9};

    vector<int> BIT_tree = construct_BIT(arr);

    update(BIT_tree, 3, 5);

    int prefix_sum_5 = query(BIT_tree, 5);

    cout << "Updated Array: ";
    for (int num : arr) {
        cout << num << " ";
    }
    cout << endl;

    cout << "BIT Tree: ";
    for (int num : BIT_tree) {
        cout << num << " ";
    }
    cout << endl;

    cout << "Prefix Sum up to Index 5: " << prefix_sum_5 << endl;

    return 0;
}
</code>
</pre>
</section>
`