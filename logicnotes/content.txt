`
<section>
<h1>
Statement
</h1>
<p>
You are given two strings 's1' and 's2'.
</p>
<p>
Your task is to find the length of the longest common subsequence of the two given strings.
</p>
<p>
If there is no common subsequence for the two given strings then return 0.
</p>
<p>
A subsequence of a string is a strings that can be obtained from another string by removing any number of characters but without changing the order of the characters.
</p>
<h1>
Example
</h1>
<p>
Suppose the input string 's1' is: "abcde"
and the input string 's2' is: "ace"
</p>
<p>
Then, the desired output is: 3
</p>
<p>
This is because the longest common subsequence of the two given strings is "ace" which has the length 3.
</p>
<p>
Now suppose the input string 's1' is: "abc"
and the input string 's2' is "abc" as well
</p>
<p>
In this case, the desired output is: 3
</p>
<p>
The reason is that the longest common subsequence of the two given strings is "abc" and its length is 3.
</p>
<h1>
Solution
</h1>
<p>
The best way to solve this problem is by using dynamic programming.
To solve the problem we can build a 2D array named 'dp' with as many rows as the length of the first string say 'l1'
and with as many columns as the length of the second string say 'l2'.
The value of 'dp[i][j]' will represent the legnth of the longest common subsequence discovered by iterating untill index 'i' in the first string and untill index 'j' in the second string.
The value of 'dp[i][0]' and 'dp[0][j]' will always be 0 since there cannot be a non-empty common subsequence when one of the strings is empty.
The value of 'dp[i][j]' will be computed recursively like this:
If s1[i] == s2[j] then we can increase the length of the current subsequence by 1 since both characters are identical.
Else we just ignore the current character from either string 's1' or string 's2' and continue the search by picking the maximum length when ignoring either 's1[i]' or 's2[j]'.
</p>
<h1>
Implementation
</h1>
<pre>
<code>
#include < iostream >
#include < cstring >
using namespace std;

string s1, s2;
int l1, l2;
vector<vector<int>> dp;

int main()
{
    //Read the input
    cin>>s1>>s2;
    l1 = s1.size();
    l2 = s2.size();
    dp.resize(l1, std::vector<int>(l2, 0));

    //Use dynamic programming
    for(int i = 0;i < l1+1;i++)
        for(int j = 0;j < l2+1;j++)
            if(i == 0 || j == 0)
                dp[i][j] = 0;
            else if(s1[i-1] == s2[j-1])
                dp[i][j] = dp[i-1][j-1]+1;
            else 
                dp[i][j] = max(dp[i-1][j], dp[i][j-1]);

    //Write the output
    cout<<dp[l1][l2];

    return 0;
}
</code>
</pre>
</section>
`