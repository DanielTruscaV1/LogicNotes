`
<section>
<h1>
Statement
</h1>
<p>
Given an unsorted array of integers nums, return the length of the longest continuous increasing subsequence (i.e. subarray). The subsequence must be strictly increasing.
</p>
<p>
A continuous increasing subsequence is defined by two indices l and r (l < r) such that it is [nums[l], nums[l + 1], ..., nums[r - 1], nums[r]] and for each l <= i < r, nums[i] < nums[i + 1].
</p>
<h1>
Example
</h1>
<p>
Input: nums = [1,3,5,4,7]
</p>
<p>
Output: 3
</p>
<p>
Explanation: The longest continuous increasing subsequence is [1,3,5] with length 3.
Even though [1,3,5,7] is an increasing subsequence, it is not continuous as elements 5 and 7 are separated by element
</p>
<p>
Input: nums = [2,2,2,2,2]
</p>
<p>
Output: 1
</p>
<p>
Explanation: The longest continuous increasing subsequence is [2] with length 1. Note that it must be strictly
increasing.
</p>
<h1>
Solution
</h1>
<p>
We iterate over the input array from left to right.
</p>
<p>
If the current element is greater than the previous element then we increase the length of the subsequence.
</p>
<p>
Else we end the subsequence and check if it is the one with maximum length so far. We also start a new subsequence at this same index.
</p>
<h1>
Implementation
</h1>
<pre>
<code>
class Solution {
public:
    int findLengthOfLCIS(vector<int>& nums) {
        int n = nums.size();
        int start = 0, maxLength = 1;

        for(int i = 1;i < n;i++)
            if(nums[i-1] < nums[i])
                continue;
            else 
            {
                if(i-1-start+1 > maxLength)
                    maxLength = i-1-start+1;
                start = i;
            }
        if(n-1-start+1 > maxLength)
            maxLength = n-1-start+1;
        return maxLength;
    }
};
</code>
</pre>
</section>
`