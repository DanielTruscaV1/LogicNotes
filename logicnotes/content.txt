`
<section>
<h1>
Statement
</h1>
<p>
There is an undirected connected tree with n nodes labeled from 0 to n - 1 and n - 1 edges.
</p>
<p>
You are given the integer n and the array edges where edges[i] = [ai, bi] indicates that there is an edge between nodes ai and bi in the tree.
</p>
<p>
Return an array answer of length n where answer[i] is the sum of the distances between the ith node in the tree and all other nodes.
</p>
<h1>
Example
</h1>
<p>
Input: n = 6, edges = [[0,1],[0,2],[2,3],[2,4],[2,5]]
</p>
<p>
Output: [8,12,6,10,10,10]
</p>
<p>
We can see that dist(0,1) + dist(0,2) + dist(0,3) + dist(0,4) + dist(0,5)
equals 1 + 1 + 2 + 2 + 2 = 8.
Hence, answer[0] = 8, and so on.
</p>
<h1>
Solution
</h1>
<p>
In this problem we are asked to find the sum of the distances from a node 'i' to all other nodes and we must to this for all nodes in the tree.
</p>
<p>
The efficient approach is based on the idea of using Depth-First Search two times so that we can gather information about the steps required to go from any node to another.
</p>
<p>
We first start a DFS on the root of the tree and keep track of the number of times a node will be visited from above (meaning that if we want to visit a child of node 'a' then we have to go through node 'a' itself if we are coming from above node 'a').
</p>
<p>
At this step we also keep in mind that for each node that is a child of 'a', say it will be accessed 'x' times  in the problem scenario, then the node 'a' will also be accessed at least 'x' times for the reason explained above.
</p>
<p>
With this in mind, we can safely update the value of the answer array for the node 'a' like this 'answer[a] += x'.
</p>
<p>
Next we start another DFS on the root of the tree and we update the value of the answer array due to the fact that now we know how many times a path must go through node 'a'.
</p>
<p>
Finally we return the answer array.
</p>
<h1>
Implementation
</h1>
<pre>
<code>
class Solution {
public:

    vector<vector<int>> v;
    vector<int> ans, counter;

    void DFS1(int i, int previous)
    {
        for(auto next : v[i])
            if(next != previous)
            {
                DFS1(next, i);
                counter[i] += counter[next];
                ans[i] += ans[next]+counter[next];
            }
        counter[i]++;
    }

    void DFS2(int i, int n, int previous)
    {
        for(auto next : v[i])
            if(next != previous)
            {
                ans[next] = ans[i]-counter[next]+n-counter[next];
                DFS2(next, n, i);
            }
    }

    vector<int> sumOfDistancesInTree(int n, vector<vector<int>>& edges) {
        v.resize(n);

        for(int i = 0;i < n-1;i++)
        {
            int a = edges[i][0];
            int b = edges[i][1];
            v[a].push_back(b);
            v[b].push_back(a);
        }

        ans.resize(n);
        counter.resize(n);

        DFS1(0, -1);
        DFS2(0, n, -1);

        return ans;

    }
};
</code>
</pre>
</section>
`