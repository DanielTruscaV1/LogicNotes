`
<section>
<a href="https://leetcode.com/problems/determine-if-two-strings-are-close/description/?envType=daily-question&envId=2024-01-14">
Problem Source: LeetCode
</a>
<h1>
Statement
</h1>
<p>
Two strings are considered close if you can attain one from the other using the following operations:
</p>
<p>
Operation 1: Swap any two existing characters.
For example, abcde -> aecdb
</p>
<p>
Operation 2: Transform every occurrence of one existing character into another existing character, and do the same with the other character.
For example, aacabb -> bbcbaa (all a's turn into b's, and all b's turn into a's)
</p>
<p>
You can use the operations on either string as many times as necessary.
</p>
<p>
Given two strings, word1 and word2, return true if word1 and word2 are close, and false otherwise.
</p>
<h1>
Example
</h1>
<p>
Input: word1 = "abc", word2 = "bca"
</p>
<p>
Output: true
</p>
<p>
Explanation: You can attain word2 from word1 in 2 operations.
Apply Operation 1: "abc" -> "acb"
Apply Operation 1: "acb" -> "bca"
</p>
<p>
Input: word1 = "a", word2 = "aa"
</p>
<p>
Output: false
</p>
<p>
Explanation: It is impossible to attain word2 from word1, or vice versa, in any number of operations.
</p>
<h1>
Solution
</h1>
<p>
We use a map to keep track of whether or not a character is present in the first string and one to keep track of the frequency of the character. We do this for the second string as well.
</p>
<p>
We can then check if the same characters appear in both strings and also check if by swapping the frequencies we can get an identical string. We can achive this using a set for the frequency of each string and by comparing the two sets.
</p>
<h1>
Implementation
</h1>
<pre>
<code>
class Solution {
public:
    bool closeStrings(string word1, string word2) {
        unordered_map<char, int> m1, m2, m1_2, m2_2;
        for(auto i : word1)
        {
            m1[i]++;
            m1_2[i] = 1;
        }
        for(auto i : word2)
        {
            m2[i]++;
            m2_2[i] = 1;
        }
        if(m1_2 != m2_2)
            return false;
        multiset<int> s1, s2;
        for(auto [c, f] : m1)
            s1.insert(f);
        for(auto [c, f] : m2)
            s2.insert(f);
        return s1 == s2;
    }
};
</code>
</pre>
</section>
`