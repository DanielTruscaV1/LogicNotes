`
<section>
<h1>
Context
</h1>
<p>
In the context of Computer Science problems there are many applications for Binary Indexed Trees.
In this note you can find some of the most important and representative problems based on Binary Indexed Trees.
</p>
<h1>
Overview
</h1>
<p>
This note presents efficient solutions for the following problems:
</p>
<ul>
<li>
Range Sum Query
</li>
</ul>
<h1>
Range Sum Query
</h1>
<p>
<strong>
Statement:
</strong>
Given an array arr of size n, the task is to efficiently answer multiple queries of the form "Find the sum of elements in the subarray arr[i, j]."
</p>
<p>
<strong>
Example:
</strong>
Suppose the input array is: arr = [3, 1, 4, 2, 2, 1, 5, 9, 6].
</p>
<p>
And the input queries are: arr[2, 5], arr[1, 8], arr[4, 6]. 
</p>
<p>
Then, the expected output of the program must be: 9, 33, 8.
</p>
<p>
<strong>
Solution:
</strong>
You can use a Binary Indexed Tree (BIT) to preprocess the array and efficiently answer the range sum queries. The BIT allows you to update elements and calculate the cumulative sum up to a given index in logarithmic time.
</p>
<h1>
Implementation
</h1>
<pre>
<code>
#include < iostream >
#include < vector >
using namespace std;

class FenwickTree{
    private:
        vector< int > BIT;
    public: 
        FenwickTree(int n)
        {
            BIT.assign(n+1, 0);
        }

        void update(int index, int value)
        {
            while(index < BIT.size())
            {
                BIT[index] += val;
                index += index & -index;
            }
        }

        int query(int index)
        {
            int sum = 0;
            while(index > 0)
            {
                sum += BIT[index];
                index -= index & -index;
            }
            return sum;
        }

        int queryRange(int left, int right) {
            return query(right) - query(left - 1);
        }
}

int main()
{
    vector< int > arr = {3, 1, 4, 2, 2, 1, 5, 9, 6};
    int n = arr.size();
    FenwickTree bit(n);

    for(int i = 0;i < n;i++)
        bit.update(i+1, arr[i]);
    
    cout << "Sum in the subarray [2, 5]: " << bit.queryRange(2, 5) << '\n';
    cout << "Sum in the subarray [1, 8]: " << bit.queryRange(1, 8) << '\n';
    cout << "Sum in the subarray [4, 6]: " << bit.queryRange(4, 6) << '\n';

    return 0;
}
</code>
</pre>
<p>
Note: 'index += index & -index' increments the index to the next node in the tree. The expression index & -index extracts the rightmost set bit of the index, effectively isolating the lowest significant bit. This operation efficiently navigates the tree structure by moving from one node to the next in logarithmic time.
</p>
</section>
`