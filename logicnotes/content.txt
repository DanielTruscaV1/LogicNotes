`
<section>
<a href="https://leetcode.com/problems/find-the-city-with-the-smallest-number-of-neighbors-at-a-threshold-distance/description/">
Source of the problem: LeetCode
</a>
<h1>
Statement
</h1>
<p>
You are given a weighted undirected graph with 'n' nodes and a list of edges of the form (a, b, w) where 'a' represents the node a, 'b' represents the node b and 'w' represents the weight asociated with the edge from node a to b.
</p>
<p>
You are also given an integer 'k' which represents the distance threshold for any path in the graph.
</p>
<p>
The task is to find the node with the least number of neighbours.
</p>
<p>
Note that if there is a path from node a to node b but the weight of the path is greater than the threshold then the two nodes are not considered neightbours.
</p>
<p>
If there are multiple nodes that satisfy the condition then return the one with the greatest number.
</p>
<h1>
Solution
</h1>
<p>
We first create a matrix (2D array) that stores the minimum distance between any two nodes 'i' and 'j'.
</p>
<p>
This matrix will be created using the Warshall-Floyd algorithm in O(n^3) time complexity since if the nodes 'i' and 'k' are neighbours and if the nodes 'j' and 'k' are neighbours then the nodes 'i' and 'j' must also be neighbours.
</p>
<p>
Then we pick all nodes from 0 to n-1 and check whether or not they have the least number of neighbours by actually checking whether or not the current node is a neighbour of any of the other nodes.
We can achive this in O(n^2) time complexity by using the minimum weight matrix that has been constructed previously.
</p>
<p>
Finally we return the answer.
</p>
<h1>
Implementation
</h1>
<pre>
<code>
class Solution {
public:
    int findTheCity(int n, vector<vector<int>>& edges, int distanceThreshold) {
        int dist[n][n];

        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n; j++) {
                dist[i][j] = i == j ? 0 : 10001;
            }
        }

        for(auto edge : edges)
            dist[edge[0]][edge[1]] = dist[edge[1]][edge[0]] = edge[2];

        for (int k = 0; k < n; k++) {
            for (int i = 0; i < n; i++) {
                for (int j = 0; j < n; j++) {
                    dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j]);
                }
            }
        }
        int ans = -1;
        int minimum = INT_MAX;
        for(int i = 0;i < n;i++)
        {
            int counter = 0;
            for(int j = 0;j < n;j++)
                if(dist[i][j] <= distanceThreshold)
                    counter++;
            if(counter <= minimum)
            {
                minimum = counter;
                ans = i;
            }
        }
        return ans;
    }
};
</code>
</pre>
</section>
`