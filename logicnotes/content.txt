`
<section>
<h1>
Statement
</h1>
<p>
Consider all the leaves of a binary tree, from left to right order, the values of those leaves form a leaf value sequence.
</p>
<p>
For example, in the given tree above, the leaf value sequence is (6, 7, 4, 9, 8).
</p>
<p>
Two binary trees are considered leaf-similar if their leaf value sequence is the same.
</p>
<p>
Return true if and only if the two given trees with head nodes root1 and root2 are leaf-similar.
</p>
<h1>
Example
</h1>
<p>
Input: root1 = [3,5,1,6,2,9,8,null,null,7,4], root2 = [3,5,1,6,7,4,2,null,null,null,null,null,null,9,8]
</p>
<p>
Output: true
</p>
<h1>
Solution
</h1>
<p>
We use the preorder traversal of both trees and create the leaf value sequence array for each tree, then we check if the two arrays are identical or not and return the answer.
</p>
<h1>
Implementation
</h1>
<pre>
<code>
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:

    vector<int> v1, v2;

    void preorder1(TreeNode* current)
    {
        if(current)
        {
            preorder1(current->left);
            if(!current->left && !current->right)
                v1.push_back(current->val);
            preorder1(current->right);
        }
    }

    void preorder2(TreeNode* current)
    {
        if(current)
        {
            preorder2(current->left);
            if(!current->left && !current->right)
                v2.push_back(current->val);
            preorder2(current->right);
        }
    }

    bool leafSimilar(TreeNode* root1, TreeNode* root2) {
        preorder1(root1);
        preorder2(root2);

        int n1 = v1.size();
        int n2 = v2.size();
        if(n1 != n2)
            return false;
        for(int i = 0;i < n1;i++)
            if(v1[i] != v2[i])
                return false;
        return true;
    }
};
</code>
</pre>
</section>
`