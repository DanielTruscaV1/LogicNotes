`
<section>
<a href="https://leetcode.com/problems/redundant-connection/description/">
Problem Source: LeetCode
</a>
<h1>
Statement
</h1>
<p>
In this problem, a tree is an undirected graph that is connected and has no cycles.
</p>
<p>
You are given a graph that started as a tree with n nodes labeled from 1 to n, with one additional edge added. The added edge has two different vertices chosen from 1 to n, and was not an edge that already existed. The graph is represented as an array edges of length n where edges[i] = [ai, bi] indicates that there is an edge between nodes ai and bi in the graph.
</p>
<p>
Return an edge that can be removed so that the resulting graph is a tree of n nodes. If there are multiple answers, return the answer that occurs last in the input.
</p>
<h1>
Example
</h1>
<img src="https://assets.leetcode.com/uploads/2021/05/02/reduntant1-1-graph.jpg"/>
<p>
Input: edges = [[1,2],[1,3],[2,3]]
</p>
<p>
Output: [2,3]
</p>
<img src="https://assets.leetcode.com/uploads/2021/05/02/reduntant1-2-graph.jpg"/>

<p>
Input: edges = [[1,2],[2,3],[3,4],[1,4],[1,5]]
</p>
<p>
Output: [1,4]
</p>
<h1>
Solution
</h1>
<p>
We use the Disjoint Set Union algorithm for keeping track of the parent (representative node) of every connected component.
</p>
<h1>
Implementation
</h1>
<pre>
<code>
class Solution {
public:
    vector<int> findRedundantConnection(vector<vector<int>>& edges) {
        int n = edges.size();
        vector<int> parent(n+1), card(n+1);

        for(int i = 1;i <= n;i++)
        {
            parent[i] = i;
            card[i] = 1;
        }

        for(auto edge : edges)
        {
            int a = edge[0];
            int b = edge[1];

            int pa = find_parent(a, parent);
            int pb = find_parent(b, parent);

            if(pa == pb)
                return edge;

            if(card[pa] >= card[pb])
            {
                parent[pb] = parent[pa];
                card[pa] += card[pb];
                card[pb] = 0;
            }
            else 
            {
                parent[pa] = parent[pb];
                card[pb] += card[pa];
                card[pa] = 0;
            }
        }

        vector<int> ans;
        return ans;
    }

    int find_parent(int x, vector<int> parent)
    {
        if(parent[x] != x)
            return find_parent(parent[x], parent);
        return x;
    }
};
</code>
</pre>
</section>
`